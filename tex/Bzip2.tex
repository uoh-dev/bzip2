\documentclass{article}
%\usepackage[margin=1.3in]{geometry}
\usepackage[margin=1.84in, top=4cm]{geometry}

\date{Abgabe: \today}
\author{Florian Brohm, 7443251 \and Toprak Saricerci, 7445073}

\title{Seminar: Datenkompression\\Bzip2}

\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{xcolor}
\usepackage{graphicx}
\usepackage[ngerman]{babel}
%\usepackage{changepage}
%\usepackage[thinc]{esdiff}
%\usepackage[makeroom]{cancel}
%\usepackage{pdfpages}

%\usepackage{tikz}
%\usepackage{listings}
%\usepackage{tabularx}
\usepackage{float}
\usepackage[font=small]{caption}

%\usetikzlibrary{arrows,automata}

\usepackage[sorting=none]{biblatex}
\addbibresource{quellen.bib}

\newcommand{\bla}{\bigwedge\limits}
\newcommand{\blo}{\bigvee\limits}
\newcommand{\la}{\land}
\newcommand{\lo}{\lor}
\newcommand{\lr}{\rightarrow}
\newcommand{\llr}{\leftrightarrow}
\newcommand{\Llr}{\Leftrightarrow}
\newcommand{\lp}{\oplus}
\newcommand{\p}{\text{potenz}}
\newcommand{\R}{\Rightarrow}
\newcommand{\n}[1]{\overline{{#1}}}
\newcommand{\bb}[1]{\mathbb{{#1}}}

\newcommand{\step}[1]{&& \left|\ {#1} \right.}
\newcommand{\e}[2]{{#1}\cdot 10^{{#2}}}
\newcommand{\blue}{\textcolor{blue}}
\newcommand{\red}{\textcolor{red}}
\newcommand{\quelle}{\red{quelle }}
\newcommand{\todo}{\red{todo }}
\newcommand{\dunderline}[1]{\underline{\underline{#1}}}
\newcommand{\reff}[2]{\hyperref[{#2}]{{#1}\ref*{#2}}}

\newcommand{\para}{\par\null\par}


\renewcommand{\labelenumi}{\alph{enumi})}
\renewcommand{\labelenumii}{\roman{enumii})}
\setlength\parindent{0pt}


\usepackage{hyperref}
\hypersetup{
	colorlinks,
	linkcolor={blue},
	urlcolor={red}, 
    citecolor={blue}
}

\begin{document}
\maketitle
\newpage

{
    \hypersetup{linkcolor=blue}
    \tableofcontents
}
\listoftables
\listoffigures
\newpage
\section{Was ist Bzip2?}
\vspace*{3cm}
\section{Was ist eine Datenkompression?}
Als Datenkompression wird ein Vorgang bezeichnet, bei dem Daten so verarbeitet werden, 
dass sie mit weniger Bits darstellbar sind. Dabei kann die Kompression entweder 
\texttt{verlustfrei} oder \texttt{verlustbehaftet} sein.
\subsection{Verlustfreie und verlustbehaftete Kompressionen}
Für eine Kompression $k: E \to A$, die eine Eingabe $E \in \{0,1\}^*$ in eine Ausgabe $A \in \{0,1\}^*$
komprimiert, gilt:
\[k \text{ ist \texttt{verlustfrei}} \Llr k \text{ ist invertierbar}.\]
Bei \texttt{verlustfreien} Kompressionen wird also die Forderung gesetzt, dass die 
komprimierte Ausgabe wieder in die originale Eingabe dekomprimiert werden~kann.
\para
Dass eine Kompression verlustbehaftet ist, ist nicht immer schlimm. Wichtig ist hierbei nur, 
dass die verlorene Information für den Menschen nicht erkennbar oder zumindest 
vernachlässigbar ist. So kann zum Beispiel bei einem Bild das Farbspektrum 
verkleinert werden, ohne dass das menschliche Auge einen Unterschied bemerkt.
\begin{figure}[H]
    \centering
    \includegraphics*[width=0.5\textwidth]{images/verlustbehaftet-bild.png}
    \caption[Verlustbehaftete Kompression eines Bildes]{
        Ein Bild, welches mit dem JPEG-Verfahren komprimiert~wurde.
    }
\end{figure}
In Texten hingegen können schon kleine Informationsverluste dafür sorgen, 
dass diese nicht mehr lesbar sind.
\newpage
\subsection{Entropiekodierungen und Substitiutionskompressionen}
Bei verlustfreien Kompressionen unterscheidet man grundsätzlich zwischen den
\texttt{Entropiekodierungen} und \texttt{Substitiutionskompressionen}.
\para
\texttt{Entropiekodierungen} errechnen für die Zeichen $z \in \Sigma$ einer Eingabe einen Code 
\[c: \Sigma \to \bigcup\limits_{n\geq1} \{0,1\}^n.\]
Ziel des Codes ist es, eine Ausgabe mit kleinerer durchschnittlicher Codel\"ange, 
als die der Eingabe zu erzeugen, indem häufig auftretende Zeichen 
kürzeren Codes und seltene Zeichen längeren Codes zugewiesen werden.
Die Huffman -und arithmetische Kodierung sind Beispiele von Entropiekodierungen.
\para
\texttt{Substitiutionskompressionen} hingegen versuchen, oft wiederholende Zeichenfolgen 
zusammenzufassen und somit Redundanz in der Eingabe zu eliminieren. Bekannte Vertreter
sind hier das LZ77 Verfahren und das im folgenden Abschnit analysierte Run-Length Verfahren.
\newpage
\section{Run-length encoding} 
Die Run-Length Kodierung ist eine Substitiutionskompression, bei der sich wiederholende
Zeichenfolgen zusammengefasst werden.
\subsection{Kodierung}
Sei $aw \in \Sigma^*$ die Eingabe, wobei $a = x^n,~x\in \Sigma$ eine
sich wiederholende Zeichenfolge der Länge $n$ ist. Das Teilwort $a$ wird zu $nx$ umgeformt, 
wonach der Algorithmus mit $w$ fortführt. Folgendes ist ein Beispiel der Kodierung:
\begin{center}
    \red{jjjjjjj}kkijjj $\R$ 7j\red{kk}ijjj $\R$ 7j2k\red{i}jjj $\R$ 7j2k1i\red{jjj} $\R$ 7j2k1i3j
\end{center}
\subsection{Dekodierung}
Sei $nxw$ mit $n\in \bb{N},~x\in\Sigma$ und $w\in(\bb{N}\cup\Sigma)^*$ die Eingabe. Das Teilwort $nx$ wird
zu $x^n$ umgeformt, wonach der Algorithmus mit $w$ fortführt. Folgendes ist ein Beispiel der Kodierung:
\begin{center}
    \red{2j}1k6i3k $\R$ jj\red{1k}6i3k $\R$ jjk\red{6i}3k $\R$ jjkiiiiii\red{3k} $\R$ jjkiiiiiikkk
\end{center}
\newpage
\section{Huffman encoding}
\subsection{Kodierung}
\subsubsection{Implementierung}
\subsection{Dekodierung}
\subsubsection{Implementierung}
\newpage
\section{Transformation}
\subsection{Was ist eine Transformation?}
Transformationen sind Funktionen auf einer Menge von Eingabewörtern $\Sigma^*$, welche diese auf eine, oft gleiche, Menge von Ausgabewörtern $\Sigma'^{*}$ abbildet. Die Eingabe und das Ergebnis sind dabei jedoch gleich lang.
\\[.5cm]
Sei $T$ eine Transformation mit
\begin{equation}
    T:~\Sigma^*\rightarrow\Sigma'^*,~w\mapsto T(w)
\end{equation}
Die Anwendung einer Transformation wird im folgenden für ein Wort $w\in\Sigma^*$ gekürzt beschrieben.
\begin{equation}
    w^T:=T(w)
\end{equation}
Aus der oben genannten Definition folgt
\begin{equation}
    |w^T|=|w|
\end{equation}
Beispiele simpler Transformationen:
\begin{align*}
    abcd~&\stackrel{R}{\rightarrow}~dcba~~\text{(Umkehrung)}\\
    dbca~&\stackrel{\text{sort}}{\rightarrow}~abcd~~\text{(Lexikographische Sortierung)}\\
    abcd~&\stackrel{0}{\rightarrow}~0000~~\text{(Nulling)}
\end{align*}
Man beobachte: die Permutation ist ein Spezialfall der Transformation.
\subsection{Warum sind Transformationen nützlich?}
Das Ziel der Datenkompression ist logischerweise das Einsparen von Speicherplatz.
Wenn jedoch die Länge der Ausgabe einer Transformation der Länge der Eingabe gleicht, wozu benötigen wir sie dann?
\\[.5cm]
Transformationen können benutzt werden, um Eingaben in eine für eine Kodierung (o.Ä.) günstige Form zu bringen. Dies steigert die Effizienz der Kodierung und spart somit mehr Speicherplatz.
\\[.5cm]
Wir stellen die Forderung, dass eine Transformation invertierbar sein muss, um für (verlustfreie) Datenkompression nützlich zu sein. Die Umkehrfunktion einer Transformation $T$ wird wie folgt definiert.
\[T^{-1}:~\Sigma'^*\rightarrow\Sigma^*,~w=\bigl(w^T\bigr)^{T^{-1}}\]
Jetzt gilt es nur noch, tatsächlich nützliche Transformationen zu finden und anzuwenden.
\section{Move-to-front transform}
\subsection{Erläuterung}
MTF ist eine Transformation, welche Zeichen der Eingabe auf deren Index in einer Liste ''neulich genutzter'' Zeichen abbildet.
\\[.5cm]
Sei $\Sigma$ das Eingabealphabet mit $|\Sigma|=n$. Wir initialisieren die Liste $A(1..n)$ folgendermaßen.
\begin{equation}
    A_{1..n}=(\sigma_1,..,\sigma_n),~\sigma_1,..,\sigma_n\in\Sigma~\text{paarweise Verschieden}
\end{equation}
$A$ enthält initial das gesamte Alphabet, per konvention lexikographisch sortiert.
\\[.5cm]
Wir definieren die Hilfsfunktion $t_{\text{MTF}}$:
\begin{equation}
\begin{split}
    &t_{\text{MTF}}:\Sigma^n\times\Sigma\rightarrow\Sigma^n\times\Sigma,\\
    &t_{\text{MTF}}(A,\sigma):=(A(1\stackrel{\text{Tausch}}{\Leftrightarrow}i),i),~i=\text{Index von}~\sigma~\text{in}~A
\end{split}
\end{equation}
$t_{\text{MTF}}$ beschreibt einen Schritt des MTF-Algorithmus. Für ein Zeichen $\sigma\in\Sigma$ der Eingabe wird zunächst dessen Index in $A$ in die Ausgabe geschrieben. Anschließend wird $A_1$ mit $A_i$ getauscht.
\\[.5cm]
Mithilfe von $t_{\text{MTF}}$ lässt sich MTF nun definieren.
\begin{equation}
\begin{split}
    \text{MTF}:\Sigma^n\times\Sigma^*\rightarrow~&\Sigma^n\times\Sigma^*\\
    \text{MTF}(A,w):=~&(A^{(k)},i\circ w')\\
    \text{mit}~&(A',i)=t_{\text{MTF}}(A,w_1)\\
    &(A^{(k)},w')=\text{MTF}(A',(w_2,..,w_k))\\
    \\
    \text{MTF}(A,\epsilon):=~&(A,\epsilon)
\end{split}
\end{equation}
$A^{(k)}$ ist für die Invertierung wichtig, daher muss diese an die Ausgabe gehängt werden.
\newpage
\subsection{Inverse Transformation}
Für die Invertierung drehen wir den Algorithmus um. Zunächst definieren wir die Umkehrfunktion zu $t_{\text{MTF}}$.
\begin{equation}
\begin{split}
    &t^{-1}_{\text{MTF}}:\Sigma^n\times\Sigma\rightarrow\Sigma^n\times\Sigma\\
    &t^{-1}_{\text{MTF}}(A,i):=(A(i\stackrel{\text{Tausch}}{\Leftrightarrow}1),A_i)
\end{split}
\end{equation}
So können wir nun auch $\text{MTF}^{-1}$ definieren. Diese geht, anders als MTF, von rechts nach links (rückwärts) durch die Eingabe.
\begin{equation}
\begin{split}
    \text{MTF}^{-1}:\Sigma^n\times\Sigma^*\rightarrow~&\Sigma^n\times\Sigma^*\\
    \text{MTF}^{-1}(A^{(k)},w):=~&(A,w'\circ\sigma)\\
    \text{mit}~&(A^{(k-1)},\sigma)=t^{-1}_{\text{MTF}}(A^{(k)},w_k)\\
    &(A,w')=MTF^{-1}(A^{(k-1)},(w_1,..,w_{k-1}))
\end{split}
\end{equation}
\newpage
\section{Burrows-Wheeler transform}
\subsection{Transformation}
\subsubsection{Implementierung}
\subsection{Inverse Transformation}
\subsubsection{Implementierung}
\newpage
\section{Ergebnisse}
\subsection{Einfluss der Schritte auf die Kompression}
\printbibliography[heading=bibintoc]
\end{document}